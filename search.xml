<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数组Array方法总结</title>
    <url>/2019/%E6%95%B0%E7%BB%84Array%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="5-1-Object类型"><a href="#5-1-Object类型" class="headerlink" title="5.1 Object类型"></a>5.1 Object类型</h3><h4 id="1-对象属性访问"><a href="#1-对象属性访问" class="headerlink" title="1. 对象属性访问"></a>1. 对象属性访问</h4><p>一般来说，对象属性访问都是点表示法。</p>
<p>还一种方法，方括号表示法 []。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.name = person[<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure>

<p>当属性名还有空格时，或者使用字符串变量时，方括号表示法有大作用。</p>
<a id="more"></a>  

<h3 id="5-2-Array"><a href="#5-2-Array" class="headerlink" title="5.2 Array"></a>5.2 Array</h3><h4 id="1-定义方法"><a href="#1-定义方法" class="headerlink" title="1. 定义方法"></a>1. 定义方法</h4><ol>
<li><p>使用Array构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>() <span class="comment">//创建空数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>)  <span class="comment">//创建一个包含20个元素的数组</span></span><br><span class="line"><span class="comment">//（注意）</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'red'</span>) <span class="comment">//创建包含一个项red的数组</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>) <span class="comment">//创建包含两个项的数组，项内容为空。区别前者。</span></span><br><span class="line"><span class="comment">//可以省略new，直接var arr = Array('red')</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字面量构造</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr = []</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-length属性"><a href="#2-length属性" class="headerlink" title="2. length属性"></a>2. length属性</h4><p>数组的length属性不是只读的，他还是可写的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(color[<span class="number">2</span>]); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>将length属性手动设置为比数组小时，越界的项会变成undefined。</p>
<p>而如果将length设置成比数组个数大，多余的项也会被设置为undefined。</p>
<p><strong>奇淫技巧</strong>：添加新的数组项：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">colors.[colors.length] = <span class="string">'black'</span></span><br></pre></td></tr></table></figure>

<p>因为数组的最后一项是length-1.</p>
<h4 id="3-数组方法"><a href="#3-数组方法" class="headerlink" title="3. 数组方法"></a>3. 数组方法</h4><h5 id="3-1-检测数组"><a href="#3-1-检测数组" class="headerlink" title="3.1 检测数组"></a>3.1 检测数组</h5><p>新增<strong>Array.isArray（）</strong>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="built_in">Array</span>.isArray(arr) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h5 id="3-2-转换方法"><a href="#3-2-转换方法" class="headerlink" title="3.2 转换方法"></a>3.2 转换方法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</span><br><span class="line">alert(colors.toString()); <span class="comment">//返回字符串，用逗号连接。"red,blue,green"</span></span><br><span class="line">alert(colors.valueOf());  <span class="comment">//返回自身（数组），['red','blue','green']</span></span><br></pre></td></tr></table></figure>

<p>toString()方法还有一个实现方法——join函数。join函数返回字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</span><br><span class="line">arr.join(<span class="string">','</span>); <span class="comment">//"red,blue,green"，不传参时，默认用逗号分隔</span></span><br><span class="line">arr.join(<span class="string">'|'</span>); <span class="comment">//"red|blue|green"</span></span><br></pre></td></tr></table></figure>

<p>#####3.3 栈与队列方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
<th>返回值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>push（入栈）</td>
<td>将参数逐个添加到数组末尾</td>
<td>修改后的数组长度</td>
<td>参数1-*</td>
</tr>
<tr>
<td>pop（出栈）</td>
<td>从数组末尾移除一项</td>
<td>移除的项</td>
<td>无参</td>
</tr>
<tr>
<td>shift（出列）</td>
<td>从数组头部移除一项</td>
<td>移除的项</td>
<td></td>
</tr>
<tr>
<td>unshift（入列）</td>
<td>从数组头部添加项</td>
<td>修改后的数组长度</td>
<td>参数1-*</td>
</tr>
</tbody></table>
<p>push和shift模拟队列，unshift和pop模拟反向队列。</p>
<p><strong>注意：以上方法都会改变原数组</strong></p>
<h5 id="3-4-排序方法"><a href="#3-4-排序方法" class="headerlink" title="3.4 排序方法"></a>3.4 排序方法</h5><ol>
<li><p>reverse<br>翻转数组，返回翻转后的数组。</p>
</li>
<li><p>sort</p>
<p>返回排序的后的数组。但是是按字符串进行排序的。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">150</span>,<span class="number">15</span>]</span><br><span class="line">arr.sort() <span class="comment">//0,1,10,15,5</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>要使用数值进行排列的话，则需要传入函数。如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1,value2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value1 &lt; value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value1 &gt; value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr.sort(compare); <span class="comment">// 0,1,5,10,15</span></span><br><span class="line">(更简便的方法是)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1,value2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value1 - value2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<strong>会改变原数组！</strong></p>
<h5 id="3-5-操作方法"><a href="#3-5-操作方法" class="headerlink" title="3.5 操作方法"></a>3.5 操作方法</h5><ol>
<li><p>concat（拼接）</p>
<p>基于当前数组，创建一个新数组，并返回新创建的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.concat(<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>]); <span class="comment">//[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<p><strong>参数是字符串还是数组，都是直接往里面拼接元素，没有差别。</strong></p>
</li>
</ol>
<ol start="2">
<li><p>slice（切割）</p>
<p>基于当前数组的一个或多个项创建一个新数组。<strong>参数为一个或者2个。</strong></p>
<p><strong>（当参数为空时，返回数组本身）*</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">colors.slice(<span class="number">1</span>); <span class="comment">//[2,3,4,5,6]</span></span><br><span class="line">colors.slice(<span class="number">1</span>,<span class="number">4</span>) <span class="comment">//[2,3,4](左闭右开)</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>参数可以为负数，-1即为最后一个。如果结束位置小于起始位置，则返回空数组。</p>
</li>
</ol>
<ol start="3">
<li><p>splice（最强大）</p>
<p>主要用途是向数组的中部插入项。</p>
<blockquote>
<ol>
<li>删除：splice（a,b)，a：要删除的第一项的位置；b：要删除的项数。</li>
<li>插入：splice（a,b,c…)，a：起始位置；b:要删除的项数；c：插入的项</li>
<li>替换：splice（a,b,c…)，a：起始位置；b:要删除的项数；c：插入的项</li>
</ol>
</blockquote>
</li>
</ol>
<p>splice始终返回一个数组，数组为删除的项的集合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</span><br><span class="line">arr.splice(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">//返回[red]；</span></span><br><span class="line">alert(arr); <span class="comment">//[blue','green'],arr数组被修改</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">'yellow'</span>,<span class="string">'orange'</span>); <span class="comment">//返回[]</span></span><br><span class="line">alert(arr); <span class="comment">// ['red','yellow','orange','blue','green']</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'green'</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="string">'yellow'</span>,<span class="string">'orange'</span>); <span class="comment">//返回['blue']</span></span><br><span class="line">alert(arr); <span class="comment">// ['red','yellow','orange','green'],blue被删了</span></span><br></pre></td></tr></table></figure>

<h5 id="3-6-位置方法"><a href="#3-6-位置方法" class="headerlink" title="3.6 位置方法"></a>3.6 位置方法</h5><ul>
<li>indexOf，lastindexOf</li>
</ul>
<p>接受两个参数，indexOf（a，b）：要查找的项和表示查找起点位置的索引（可选）。</p>
<p>查找时比较两个项，使用的是全等（===）。</p>
<p>两个方法返回的都是要查找的项在数组中的索引，若找不到，则返回-1。</p>
<p>lastindexOf从后面往前找。</p>
<h5 id="3-7-迭代方法"><a href="#3-7-迭代方法" class="headerlink" title="3.7 迭代方法"></a>3.7 迭代方法</h5><p>有5个迭代方法，每个方法接受两个参数：每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this的值。</p>
<p>传入的这些方法中的函数都会接受三个参数：1.数组项的值 2.该项在数组的中的位置 3.数组对象本身。<strong>函数参数可以省略一些。</strong></p>
<ol>
<li><p>every（）<br>对数组中的每一项运行给定函数，如果每一项都true，则返回<strong>true</strong>。</p>
</li>
<li><p>some（）</p>
<p>对数组中的每一项运行给定函数，如果其中有一项为true，则返回<strong>true</strong>。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(item &gt; <span class="number">2</span>)</span><br><span class="line">&#125;) <span class="comment">//fasle</span></span><br><span class="line"></span><br><span class="line">arr.soome(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(item &gt; <span class="number">2</span>)</span><br><span class="line">&#125;) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>filter()</p>
<p>对数组中的每一项运行给定函数，返回该函数返回true的项组成的数组。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(item &gt; <span class="number">2</span>)</span><br><span class="line">&#125;) <span class="comment">//[3,4,5,6]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>forEach()</p>
<p>对数组中的每一项运行给定函数，该方法没有返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(item &gt; <span class="number">2</span>)</span><br><span class="line">&#125;) <span class="comment">//[3,4,5,6]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>map()</p>
<p>对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//执行操作，如console.log</span></span><br><span class="line">&#125;) <span class="comment">//无返回值</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="3-5-归并方法"><a href="#3-5-归并方法" class="headerlink" title="3.5 归并方法"></a>3.5 归并方法</h5><p>reduce和reduceRight，左边和右边的区别。</p>
<p>方法接受两个参数：在每一项运行的函数，和（可选的）作为归并基础的初始值。函数有4个参数：前一个值、当前值、项的索引值和数组对象。这个函数返回的任意值都会作为第一个参数传递给下一项。例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,cur,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'index='</span>,index,<span class="string">'prev='</span>,prev,<span class="string">'cur='</span>,cur);</span><br><span class="line">    <span class="keyword">return</span> prev + cur; <span class="comment">//如果没有return，则prev为undefined</span></span><br><span class="line">&#125;)</span><br><span class="line">alert(sum); <span class="comment">//15</span></span><br><span class="line">index= <span class="number">1</span> prev= <span class="number">1</span>  cur= <span class="number">2</span></span><br><span class="line">index= <span class="number">2</span> prev= <span class="number">3</span>  cur= <span class="number">3</span></span><br><span class="line">index= <span class="number">3</span> prev= <span class="number">6</span>  cur= <span class="number">4</span></span><br><span class="line">index= <span class="number">4</span> prev= <span class="number">10</span> cur= <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>通过例子可知：</p>
<ol>
<li>第一次迭代发生在第二个数组上，此时第一个参数是数组第一项，第二个参数数组第二项。</li>
<li>prev需要手动返回，如果没有返回，除了第一次执行时是第一项，后面的prev为undefined。</li>
</ol>
<h5 id="3-6-总结："><a href="#3-6-总结：" class="headerlink" title="3.6 总结："></a>3.6 总结：</h5><table>
<thead>
<tr>
<th>方法名</th>
<th></th>
<th>返回值</th>
<th>原数组改变?</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>pop</td>
<td>不需要参数</td>
<td>移除的项</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>push</td>
<td>0到多个项</td>
<td>数组长度</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>shift</td>
<td>不需要参数</td>
<td>移除的项</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>unshift</td>
<td>(‘red’,’green’,…)</td>
<td>数组长度</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>reverse</td>
<td>(),无参数</td>
<td>改变的原数组</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>sort</td>
<td>(),无参数</td>
<td>改变的原数组</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>concat</td>
<td>(‘red’,[..]…)</td>
<td>新数组</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>slice</td>
<td>(0,1)</td>
<td>新数组</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>splice</td>
<td>(1,0,’red’)</td>
<td>数组(被删除的项)</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>indexOf</td>
<td>(4,4)</td>
<td>下标</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>every</td>
<td>(item,index,array)</td>
<td>布尔</td>
<td>不改变</td>
<td></td>
</tr>
<tr>
<td>filter</td>
<td>(item,index,array)</td>
<td>数组</td>
<td>不改变</td>
<td></td>
</tr>
<tr>
<td>forEach</td>
<td>(item,index,array)</td>
<td>无返回值</td>
<td>不改变</td>
<td></td>
</tr>
<tr>
<td>map</td>
<td>(item,index,array)</td>
<td>数组</td>
<td>不改变</td>
<td></td>
</tr>
<tr>
<td>some</td>
<td>(item,index,array)</td>
<td>布尔</td>
<td>不改变</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>reduce</td>
<td>(prev,cur,index,array)</td>
<td>看函数的return</td>
<td>不改变</td>
<td></td>
</tr>
</tbody></table>
<p><strong>备注</strong>：</p>
<ol>
<li>slice()或slice(0)，可以用用来复制数组。或者使用concat( 要复制的数组)。</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>小红书</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客发布</title>
    <url>/2019/hexo%E5%8D%9A%E5%AE%A2%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<h3 id="1-编写md文档"><a href="#1-编写md文档" class="headerlink" title="1. 编写md文档"></a>1. 编写md文档</h3><p> 在 hexo\scaffolds\post 下对应的文件夹中编写md文档</p>
<p> 格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">categories: 分类名</span><br><span class="line">tags: 	</span><br><span class="line">	- 标签1	</span><br><span class="line">	- 标签2</span><br><span class="line">---</span><br><span class="line">内容......</span><br><span class="line">&lt;!-- more --&gt;   // 截止显示至此，并解析成‘阅读全文’按钮</span><br><span class="line">内容......</span><br></pre></td></tr></table></figure>

<a id="more"></a>  

<h3 id="2-上传博文"><a href="#2-上传博文" class="headerlink" title="2. 上传博文"></a>2. 上传博文</h3><p>创建新博客：<code>hexo new &quot;my-second-blog&quot;</code></p>
<p>部署博客： <code>hexo g</code></p>
<p>上传博客到github： <code>hexo d</code></p>
<p>本地查看博客： <code>hexo s</code></p>
<p>一般步骤为： <code>hexo s -g</code></p>
<p>清除： <code>hexo clean</code></p>
]]></content>
      <categories>
        <category>随笔笔记</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>详解toString和valueOf</title>
    <url>/2019/%E8%AF%A6%E8%A7%A3toString%E5%92%8CvalueOf/</url>
    <content><![CDATA[<h2 id="1-toString"><a href="#1-toString" class="headerlink" title="1.toString"></a>1.toString</h2><h3 id="1-使用定义"><a href="#1-使用定义" class="headerlink" title="1.使用定义"></a>1.使用定义</h3><p>作用：每个对象都有一个 <code>toString()</code> 方法，当该对象被表示为一个文本值时，或者一个对象以预期的<strong>字符串方式</strong>引用时自动调用。默认情况下，<code>toString()</code> 方法被每个 <code>Object</code> 对象继承。如果此方法在自定义对象中未被覆盖，<code>toString()</code> 返回 “[object <em>type</em>]”，其中 <code>type</code> 是对象的类型。</p>
<p><strong>注意：</strong>每个对象对会重写toString方法，一般都是重写为输出该对象的<strong>字符串</strong>。</p>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bol = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">5</span>;</span><br><span class="line">bol.toString()	<span class="comment">//"true"</span></span><br><span class="line">num.toString()  <span class="comment">//"5"</span></span><br></pre></td></tr></table></figure>

<p>对函数：</p>
<p>一样输出函数的字符串！<strong>可见函数的toString也重写了</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">55</span>)&#125;</span><br><span class="line">foo.toString()</span><br><span class="line"><span class="comment">//"function foo ()&#123;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">55</span>)&#125;<span class="string">"</span></span><br></pre></td></tr></table></figure>

<p>但是<strong>对象(Object)</strong>的toString方法是原方法，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">"ggg"</span>&#125;</span><br><span class="line">obj.toString()	<span class="comment">//"[object Object]"</span></span><br></pre></td></tr></table></figure>

<h3 id="2-使用-toString-检测对象类型"><a href="#2-使用-toString-检测对象类型" class="headerlink" title="2.使用 toString() 检测对象类型"></a>2.使用 <code>toString()</code> 检测对象类型</h3><p>可以通过 <code>toString()</code> 来获取每个对象的类型。为了每个对象都能通过 <code>Object.prototype.toString()</code> 来检测，需要以 <code>Function.prototype.call()</code> 或者 <code>Function.prototype.apply()</code> 的形式来调用，传递要检查的对象作为第一个参数，称为 <code>thisArg</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line">toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>); <span class="comment">// [object Date]</span></span><br><span class="line">toString.call(<span class="keyword">new</span> <span class="built_in">String</span>); <span class="comment">// [object String]</span></span><br><span class="line">toString.call(<span class="built_in">Math</span>); <span class="comment">// [object Math]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Since JavaScript 1.8.5</span></span><br><span class="line">toString.call(<span class="literal">undefined</span>); <span class="comment">// [object Undefined]</span></span><br><span class="line">toString.call(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>输出的值里，type的首字母是<strong>大写</strong>的！！！</p>
<p>（要使用.call才行，因为只用Object的toString函数是原始的，所以用.call将对象传入，才能执行。）</p>
<h2 id="2-valueOf"><a href="#2-valueOf" class="headerlink" title="2.valueOf"></a>2.valueOf</h2><h3 id="1-使用定义："><a href="#1-使用定义：" class="headerlink" title="1.使用定义："></a>1.使用定义：</h3><p>JavaScript调用<code>valueOf</code>方法将对象转换为原始值。你很少需要自己调用<code>valueOf</code>方法；当遇到要预期的原始值的对象时，JavaScript会自动调用它。</p>
<p>默认情况下，<code>valueOf</code>方法由<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener"><code>Object</code></a>后面的每个对象继承。 每个内置的核心对象都会覆盖此方法以返回适当的值。如果对象没有原始值，则<code>valueOf</code>将返回对象本身。</p>
<p>JavaScript的许多内置对象都重写了该函数，以实现更适合自身的功能需要。因此，不同类型对象的valueOf()方法的返回值和返回值类型均可能不同。</p>
<pre><code>怎么理解自动调用呢？如下：</code></pre><p>1.首先比较两者的差异：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">arr.toString()	<span class="comment">//"1,2,3,4"</span></span><br><span class="line">arr.valueOf()	<span class="comment">//(4) [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>valueOf就是返回本身的原始值！！！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bol = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="built_in">console</span>.log(bol)	<span class="comment">// Boolean &#123;true&#125;</span></span><br><span class="line">bol.valueOf()	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>可以看到，对于用对象定义的值，valueOf会返回数据类型定义的值！！这就是他的作用！</p>
<p><strong>至于自动调用</strong>，那是当你用new Boolean定义时，代码用到<code>if(bol)</code>的情况，会自动调用ValueOf方法。</p>
<p><strong>不同类型对象的valueOf()方法的返回值</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>对象</strong></th>
<th align="left"><strong>返回值</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Array</td>
<td align="left">返回数组对象本身。</td>
</tr>
<tr>
<td align="left">Boolean</td>
<td align="left">布尔值。</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。</td>
</tr>
<tr>
<td align="left">Function</td>
<td align="left">函数本身。</td>
</tr>
<tr>
<td align="left">Number</td>
<td align="left">数字值。</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="left">对象本身。这是默认情况。</td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">字符串值。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Math 和 Error 对象没有 valueOf 方法</td>
</tr>
</tbody></table>
<h3 id="2-使用valueOf："><a href="#2-使用valueOf：" class="headerlink" title="2.使用valueOf："></a>2.使用valueOf：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Array：返回数组对象本身</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">"ABC"</span>, <span class="literal">true</span>, <span class="number">12</span>, <span class="number">-5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array.valueOf() === array);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Date：当前时间距1970年1月1日午夜的毫秒数</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2013</span>, <span class="number">7</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">11</span>, <span class="number">59</span>, <span class="number">230</span>);</span><br><span class="line"><span class="built_in">console</span>.log(date.valueOf());   <span class="comment">// 1376838719230</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number：返回数字值</span></span><br><span class="line"><span class="keyword">var</span> num =  <span class="number">15.26540</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.valueOf());   <span class="comment">// 15.2654</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔：返回布尔值true或false</span></span><br><span class="line"><span class="keyword">var</span> bool = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bool.valueOf() === bool);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new一个Boolean对象</span></span><br><span class="line"><span class="keyword">var</span> newBool = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// valueOf()返回的是true，两者的值相等</span></span><br><span class="line"><span class="built_in">console</span>.log(newBool.valueOf() == newBool);   <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 但是不全等，两者类型不相等，前者是boolean类型，后者是object类型</span></span><br><span class="line"><span class="built_in">console</span>.log(newBool.valueOf() === newBool);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function：返回函数本身</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log( foo.valueOf() === foo );   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> foo2 =  <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"return x + y;"</span>);</span><br><span class="line"><span class="built_in">console</span>.log( foo2.valueOf() );</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ƒ anonymous(x,y</span></span><br><span class="line"><span class="comment">) &#123;</span></span><br><span class="line"><span class="comment">return x + y;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object：返回对象本身</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">"张三"</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log( obj.valueOf() === obj );   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String：返回字符串值</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"http://www.xyz.com"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( str.valueOf() === str );   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new一个字符串对象</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"http://www.xyz.com"</span>);</span><br><span class="line"><span class="comment">// 两者的值相等，但不全等，因为类型不同，前者为string类型，后者为object类型</span></span><br><span class="line"><span class="built_in">console</span>.log( str2.valueOf() === str2 );   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>对于基本数据类型：string、number、boolean，如果用new定义，valueOf后返回的值（基本数据类型），不全等于 本身（对象）。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>详解this绑定</title>
    <url>/2019/%E8%AF%A6%E8%A7%A3this%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="1-this绑定"><a href="#1-this绑定" class="headerlink" title="1.this绑定"></a>1.<code>this</code>绑定</h1><h2 id="1-this"><a href="#1-this" class="headerlink" title="1 . this"></a>1 . <code>this</code></h2><p>什么是<code>this</code> ？在讨论<code>this</code>绑定前，我们得先搞清楚this代表什么。</p>
<a id="more"></a>

<ol>
<li>this是JavaScript的关键字之一。它是 对象 自动生成的一个内部对象，只能在 对象 内部使用。随着函数使用场合的不同，this的值会发生变化。</li>
<li><strong>this指向什么，完全取决于 什么地方以什么方式调用，而不是 创建时</strong>。（比较多人误解的地方）（它非常语义化，this在英文中的含义就是 <strong>这，这个</strong> ，但这其实起到了一定的误导作用，因为this并不是一成不变的，并不一定一直指向当前 <strong>这个</strong>）</li>
</ol>
<h2 id="2-this-绑定规则"><a href="#2-this-绑定规则" class="headerlink" title="2 . this 绑定规则"></a>2 . <code>this</code> 绑定规则</h2><p>掌握了下面介绍的4种绑定的规则，那么<strong>你只要看到函数调用就可以判断 this 的指向了</strong>。</p>
<h3 id="2-1-默认绑定"><a href="#2-1-默认绑定" class="headerlink" title="2 .1 默认绑定"></a>2 .1 默认绑定</h3><p>考虑下面代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);    <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>这种就是典型的默认绑定，我们看看foo调用的位置，”光杆司令“，像 <strong>这种直接使用而不带任何修饰的函数调用</strong> ，就 <strong>默认且只能</strong> 应用 默认绑定。</p>
<p>那默认绑定到哪呢，一般是<code>window</code>上，严格模式下 是<code>undefined</code>。</p>
<h3 id="2-2-隐性绑定"><a href="#2-2-隐性绑定" class="headerlink" title="2 .2 隐性绑定"></a>2 .2 隐性绑定</h3><p>代码说话:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a : <span class="number">10</span>,</span><br><span class="line">    foo : foo</span><br><span class="line">&#125;</span><br><span class="line">foo();                <span class="comment">// ?</span></span><br><span class="line"></span><br><span class="line">obj.foo();            <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>答案 : undefined 10</p>
<p><code>foo()</code>的这个写法熟悉吗，就是我们刚刚写的默认绑定,等价于打印<code>window.a</code>,故输出<code>undefined</code> ,<br>下面<code>obj.foo()</code>这种大家应该经常写，这其实就是我们马上要讨论的 <strong>隐性绑定</strong> 。</p>
<p>函数foo执行的时候有了<strong>上下文对象</strong>，即 <code>obj</code>。这种情况下，<strong>函数里的this默认绑定为上下文对象</strong>，等价于打印<code>obj.a</code>,故输出<code>10</code> 。</p>
<p>如果是链性的关系，比如 <code>xx.yy.obj.foo();</code>, 上下文取函数的直接上级，即紧挨着的那个，或者说对象链的最后一个。</p>
<h3 id="2-3-显性绑定"><a href="#2-3-显性绑定" class="headerlink" title="2 .3 显性绑定"></a>2 .3 显性绑定</h3><h4 id="2-3-1-隐性绑定的限制"><a href="#2-3-1-隐性绑定的限制" class="headerlink" title="2 .3 .1 隐性绑定的限制"></a>2 .3 .1 隐性绑定的限制</h4><p>在我们刚刚的 <strong>隐性绑定中有一个致命的限制，就是上下文必须包含我们的函数</strong> ，例：<code>var obj = { foo : foo }</code>,如果上下文不包含我们的函数用隐性绑定明显是要出错的，<strong>不可能每个对象都要加这个函数</strong> ,那样的话扩展,维护性太差了，我们接下来聊的就是直接 <strong>给函数强制性绑定this</strong>。</p>
<h4 id="2-3-2-call-apply-bind"><a href="#2-3-2-call-apply-bind" class="headerlink" title="2 .3 .2 call apply bind"></a>2 .3 .2 call apply bind</h4><p>这里我们就要用到 js 给我们提供的函数 call 和 apply，<strong>它们的作用都是改变函数的this指向</strong>，<strong>第一个参数都是 设置this对象</strong>。</p>
<p>两个函数的区别：</p>
<ol>
<li>call从第二个参数开始所有的参数都是 原函数的参数。</li>
<li>apply只接受两个参数，且第二个参数必须是数组，这个数组代表原函数的参数列表。</li>
</ol>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a+b);</span><br><span class="line">&#125;</span><br><span class="line">foo.call(<span class="literal">null</span>,<span class="string">'海洋'</span>,<span class="string">'饼干'</span>);        <span class="comment">// 海洋饼干  这里this指向不重要就写null了</span></span><br><span class="line">foo.apply(<span class="literal">null</span>, [<span class="string">'海洋'</span>,<span class="string">'饼干'</span>] );     <span class="comment">// 海洋饼干</span></span><br></pre></td></tr></table></figure>

<p>除了 call，apply函数以外，还有一个改变this的函数 bind ，它和call,apply都不同。</p>
<p><strong>bind只有一个函数，且不会立刻执行，只是将一个值绑定到函数的this上,并将绑定好的函数返回</strong>。例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span> : <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">foo = foo.bind(obj);</span><br><span class="line">foo();                    <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>（bind函数非常特别，下次和大家一起讨论它的源码）</p>
<h4 id="2-3-2-显性绑定"><a href="#2-3-2-显性绑定" class="headerlink" title="2 .3 .2 显性绑定"></a>2 .3 .2 显性绑定</h4><p>开始正题，上代码，就用上面隐性绑定的例子 :</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a : <span class="number">10</span>            <span class="comment">//去掉里面的foo</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(obj);        <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>我们将隐性绑定例子中的 上下文对象 里的函数去掉了，显然现在不能用 <code>上下文.函数</code> 这种形式来调用函数，大家看代码里的显性绑定代码<code>foo.call(obj)</code>，看起来很怪，和我们之前所了解的函数调用不一样。</p>
<p>其实call 是 foo 上的一个函数,在改变this指向的同时执行这个函数。</p>
<p>（想要深入理解 [<code>call apply bind this硬绑定,软绑定,箭头函数绑定</code> ] 等更多黑科技 的小伙伴欢迎关注我或本文的评论，最近我会单独做一期放到一起写一篇文章）（<strong>不想看的小伙伴不用担心，不影响对本文的理解</strong>）</p>
<h3 id="2-4-new-绑定"><a href="#2-4-new-绑定" class="headerlink" title="2 .4 new 绑定"></a>2 .4 new 绑定</h3><h4 id="2-4-1-什么是-new"><a href="#2-4-1-什么是-new" class="headerlink" title="2 .4 .1 什么是 new"></a>2 .4 .1 什么是 <code>new</code></h4><p>学过面向对象的小伙伴对new肯定不陌生，js的new和传统的面向对象语言的new的作用都是创建一个新的对象，但是他们的机制完全不同。</p>
<p>创建一个新对象少不了一个概念，那就是<code>构造函数</code>，传统的面向对象 构造函数 是类里的一种特殊函数，要创建对象时使用<code>new 类名()</code>的形式去调用类中的构造函数，而js中就不一样了。</p>
<p><strong>js中的只要用new修饰的 函数就是’构造函数’</strong>，准确来说是 <strong>函数的构造调用</strong>，因为在js中并不存在所谓的’构造函数’。</p>
<p>那么用new 做到函数的<code>构造调用</code>后，js帮我们做了什么工作呢:</p>
<ol>
<li>创建一个新对象。</li>
<li>把这个新对象的<code>__proto__</code>属性指向 原函数的<code>prototype</code>属性。(即继承原函数的原型)</li>
<li><strong>将这个新对象绑定到 此函数的this上</strong> 。</li>
<li>返回新对象，如果这个函数没有返回其他<strong>对象</strong>。</li>
</ol>
<p>第三条就是我们下面要聊的new绑定</p>
<h4 id="2-4-2-new-绑定"><a href="#2-4-2-new-绑定" class="headerlink" title="2 .4 .2 new 绑定"></a>2 .4 .2 new 绑定</h4><p>不哔哔，看代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();                    <span class="comment">// window对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);    <span class="comment">// 10   默认绑定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> foo();      <span class="comment">// foo&#123; a : 10 &#125;  创建的新对象的默认名为函数名</span></span><br><span class="line">                          <span class="comment">// 然后等价于 foo &#123; a : 10 &#125;;  var obj = foo;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a);       <span class="comment">// 10    new绑定</span></span><br></pre></td></tr></table></figure>

<p><strong>使用new调用函数后，函数会 以自己的名字 命名 和 创建 一个新的对象，并返回。</strong></p>
<p>特别注意 : 如果原函数返回一个对象类型，那么将无法返回新对象,你将丢失绑定this的新对象，例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"捣蛋鬼"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> foo();</span><br><span class="line"><span class="built_in">console</span>.log(obj.a);       <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);         <span class="comment">// "捣蛋鬼"</span></span><br></pre></td></tr></table></figure>

<p><strong>我的补充</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"捣蛋鬼"</span>);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> foo();	<span class="comment">//foo &#123;a: 10&#125;</span></span><br></pre></td></tr></table></figure>

<p>以上，this会输出以函数自己的名字 命名的对象。</p>
<p><strong>可见</strong>：原函数先返回一个新的对象类型，再将这个对象的地址赋值给obj的。</p>
<h4 id="2-4-3构造函数绑定（我的）"><a href="#2-4-3构造函数绑定（我的）" class="headerlink" title="2.4.3构造函数绑定（我的）"></a>2.4.3构造函数绑定（我的）</h4><p>构造函数绑定跟new是一个东西的！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Obj(<span class="string">'tony'</span>); <span class="comment">//window</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Obj(<span class="string">'tony'</span>);	<span class="comment">//obj&#123;name:'tony'&#125;</span></span><br></pre></td></tr></table></figure>

<p>new的过程，将this绑定到新对象身上的。但原始函数的this指向的是window！！</p>
<h3 id="2-5-this绑定优先级"><a href="#2-5-this绑定优先级" class="headerlink" title="2 .5 this绑定优先级"></a>2 .5 this绑定优先级</h3><p><em>过程是些无聊的代码测试，我直接写出优先级了</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</span><br></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 . 总结"></a>3 . 总结</h2><ol>
<li><p>如果函数被<code>new</code> 修饰</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this绑定的是新创建的对象，例:var bar = new foo(); 函数 foo 中的 this 就是一个叫foo的新创建的对象 , 然后将这个对象赋给bar , 这样的绑定方式叫 new绑定 .</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果函数是使用<code>call,apply,bind</code>来调用的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this绑定的是 call,apply,bind 的第一个参数.例: foo.call(obj); , foo 中的 this 就是 obj , 这样的绑定方式叫 显性绑定 .</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果函数是在某个 上下文对象 下被调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this绑定的是那个上下文对象，例 : var obj = &#123; foo : foo &#125;; obj.foo(); foo 中的 this 就是 obj . 这样的绑定方式叫 隐性绑定 .</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果都不是，即使用默认绑定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例:function foo()&#123;...&#125; foo() ,foo 中的 this 就是 window.(严格模式下默认绑定到undefined).</span><br><span class="line">这样的绑定方式叫 默认绑定 .</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="4-面试题解析"><a href="#4-面试题解析" class="headerlink" title="4 . 面试题解析"></a>4 . 面试题解析</h2><p><strong>1.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">20</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);        <span class="comment">// ?</span></span><br><span class="line">        <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);    </span><br><span class="line">            &#125;</span><br><span class="line">        foo();                      <span class="comment">// ?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.f();</span><br></pre></td></tr></table></figure>

<hr>
<p>———————–答案———————<br>答案 ： 20 10<br>解析 ：考点 <strong>1.</strong> this默认绑定 <strong>2.</strong> this隐性绑定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">20</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);    <span class="comment">// 20</span></span><br><span class="line">                                <span class="comment">// 典型的隐性绑定,这里 f 的this指向上下文 obj ,即输出 20</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); </span><br><span class="line">            &#125;</span><br><span class="line">        foo();       <span class="comment">// 10</span></span><br><span class="line">                     <span class="comment">//有些人在这个地方就想当然的觉得 foo 在函数 f 里,也在 f 里执行，</span></span><br><span class="line">                     <span class="comment">//那 this 肯定是指向obj 啊 , 仔细看看我们说的this绑定规则 , 对应一下很容易</span></span><br><span class="line">                     <span class="comment">//发现这种'光杆司令'，是我们一开始就示范的默认绑定,这里this绑定的是window</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.f();</span><br></pre></td></tr></table></figure>

<p><strong>2.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = arg;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> b = foo(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.a);    <span class="comment">// ?</span></span><br><span class="line"><span class="built_in">console</span>.log(b.a);    <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<hr>
<p>———————–答案———————</p>
<p>答案 ： undefined 10<br>解析 ：考点 <strong>1.</strong> 全局污染 <strong>2.</strong> this默认绑定</p>
<p>这道题很有意思，问题基本上都集中在第一undefined上，这其实是题目的小陷阱，但是追栈的过程绝对精彩<br>让我们一步步分析这里发生了什么：</p>
<ol>
<li>foo(1)执行，应该不难看出是默认绑定吧 , this指向了window，函数里等价于 window<strong>.</strong>a = 1,return window;</li>
<li>var a = foo(1) 等价于 window<strong>.</strong>a = window , 很多人都忽略了<strong>var a 就是window.a</strong> ，将刚刚赋值的 1 替换掉了。</li>
<li>所以这里的 a 的值是 window , a<strong>.</strong>a 也是window ， 即window<strong>.</strong>a = window ; window<strong>.</strong>a<strong>.</strong>a = window;</li>
<li>foo(10) 和第一次一样，都是默认绑定，这个时候，<strong>将window.a 赋值成 10</strong> ，注意这里是关键，原来window.a = window ,现在被赋值成了10，变成了值类型，所以现在 a.a = undefined。(验证这一点只需要将var b = foo(10);删掉，这里的 a.a 还是window)</li>
<li>var b = foo(10); 等价于 window.b = window;</li>
</ol>
<p>本题中所有变量的值，a = window.a = 10 , a.a = undefined , b = window , b.a = window.a = 10;</p>
<p><strong>3.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">20</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.f;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    x: <span class="number">30</span>,</span><br><span class="line">    f: obj.f</span><br><span class="line">&#125;</span><br><span class="line">obj.f();</span><br><span class="line">bar();</span><br><span class="line">obj2.f();</span><br></pre></td></tr></table></figure>

<hr>
<p>———————–答案———————<br>答案：20 10 30<br>解析：传说中的送分题，考点，辨别this绑定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">20</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.x); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.f;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    x: <span class="number">30</span>,</span><br><span class="line">    f: obj.f</span><br><span class="line">&#125;</span><br><span class="line">obj.f();    <span class="comment">// 20</span></span><br><span class="line">            <span class="comment">//有上下文，this为obj，隐性绑定</span></span><br><span class="line">bar();      <span class="comment">// 10</span></span><br><span class="line">            <span class="comment">//'光杆司令' 默认绑定  （ obj.f 只是普通的赋值操作 ）</span></span><br><span class="line">obj2.f();   <span class="comment">//30</span></span><br><span class="line">            <span class="comment">//不管 f 函数怎么折腾，this只和 执行位置和方式有关，即我们所说的绑定规则</span></span><br></pre></td></tr></table></figure>

<p><strong>4.</strong> 压轴题了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log (<span class="number">1</span>); &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>);&#125;;</span><br><span class="line">foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">3</span>);&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">4</span>);&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">5</span>);&#125;</span><br><span class="line"> </span><br><span class="line">foo.getName ();                <span class="comment">// ?</span></span><br><span class="line">getName ();                    <span class="comment">// ?</span></span><br><span class="line">foo().getName ();              <span class="comment">// ?</span></span><br><span class="line">getName ();                    <span class="comment">// ?</span></span><br><span class="line"><span class="keyword">new</span> foo.getName ();            <span class="comment">// ?</span></span><br><span class="line"><span class="keyword">new</span> foo().getName ();          <span class="comment">// ?</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> foo().getName ();      <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<hr>
<p>———————–答案———————<br>答案：2 4 1 1 2 3 3<br>解析：考点 1. new绑定 2.隐性绑定 3. 默认绑定 4.变量污染</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    getName = function () &#123; console.log (1); &#125;; </span><br><span class="line">            //这里的getName 将创建到全局window上</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">foo.getName = function () &#123; console.log(2);&#125;;   </span><br><span class="line">        //这个getName和上面的不同，是直接添加到foo上的</span><br><span class="line">foo.prototype.getName = function () &#123; console.log(3);&#125;; </span><br><span class="line">        // 这个getName直接添加到foo的原型上，在用new创建新对象时将直接添加到新对象上 </span><br><span class="line">var getName = function () &#123; console.log(4);&#125;; </span><br><span class="line">        // 和foo函数里的getName一样, 将创建到全局window上</span><br><span class="line">function getName () &#123; console.log(5);&#125;    </span><br><span class="line">        // 同上，但是这个函数不会被使用，因为函数声明的提升优先级最高，所以上面的函数表达式将永远替换</span><br><span class="line">        // 这个同名函数，除非在函数表达式赋值前去调用getName()，但是在本题中，函数调用都在函数表达式</span><br><span class="line">        // 之后，所以这个函数可以忽略了</span><br><span class="line">        </span><br><span class="line">        // 通过上面对 getName的分析基本上答案已经出来了</span><br><span class="line"></span><br><span class="line">foo.getName ();                // 2</span><br><span class="line">                               // 下面为了方便，我就使用输出值来简称每个getName函数</span><br><span class="line">                               // 这里有小伙伴疑惑是在 2 和 3 之间，觉得应该是3 , 但其实直接设置</span><br><span class="line">                               // foo.prototype上的属性，对当前这个对象的属性是没有影响的,如果要使</span><br><span class="line">                               // 用的话，可以foo.prototype.getName() 这样调用 ，这里需要知道的是</span><br><span class="line">                               // 3 并不会覆盖 2，两者不冲突 ( 当你使用new 创建对象时，这里的</span><br><span class="line">                               // Prototype 将自动绑定到新对象上，即用new 构造调用的第二个作用)</span><br><span class="line">                               </span><br><span class="line">getName ();                    // 4 </span><br><span class="line">                               // 这里涉及到函数提升的问题，不知道的小伙伴只需要知道 5 会被 4 覆盖，</span><br><span class="line">                               // 虽然 5 在 4 的下面，其实 js 并不是完全的自上而下，想要深入了解的</span><br><span class="line">                               // 小伙伴可以看文章最后的链接</span><br><span class="line">                               </span><br><span class="line">foo().getName ();              // 1 </span><br><span class="line">                               // 这里的foo函数执行完成了两件事, 1. 将window.getName设置为1,</span><br><span class="line">                               // 2. 返回window , 故等价于 window.getName(); 输出 1</span><br><span class="line">getName ();                    // 1</span><br><span class="line">                               // 刚刚上面的函数刚把window.getName设置为1,故同上 输出 1</span><br><span class="line">                               </span><br><span class="line">new foo.getName ();            // 2</span><br><span class="line">                               // new 对一个函数进行构造调用 , 即 foo.getName ,构造调用也是调用啊</span><br><span class="line">                               // 该执行还是执行，然后返回一个新对象，输出 2 (虽然这里没有接收新</span><br><span class="line">                               // 创建的对象但是我们可以猜到，是一个函数名为 foo.getName 的对象</span><br><span class="line">                               // 且__proto__属性里有一个getName函数，是上面设置的 3 函数)</span><br><span class="line">                               </span><br><span class="line">new foo().getName ();          // 3</span><br><span class="line">                               // 这里特别的地方就来了,new 是对一个函数进行构造调用,它直接找到了离它</span><br><span class="line">                               // 最近的函数,foo(),并返回了应该新对象,等价于 var obj = new foo();</span><br><span class="line">                               // obj.getName(); 这样就很清晰了,输出的是之前绑定到prototype上的</span><br><span class="line">                               // 那个getName  3 ,因为使用new后会将函数的prototype继承给 新对象</span><br><span class="line">                               </span><br><span class="line">new new foo().getName ();      // 3</span><br><span class="line">                               // 哈哈，这个看上去很吓人，让我们来分解一下：</span><br><span class="line">                               // var obj = new foo();</span><br><span class="line">                               // var obj1 = new obj.getName();</span><br><span class="line">                               // 好了，仔细看看, 这不就是上两题的合体吗,obj 有getName 3, 即输出3</span><br><span class="line">                               // obj 是一个函数名为 foo的对象,obj1是一个函数名为obj.getName的对象</span><br></pre></td></tr></table></figure>

<h2 id="5-箭头函数的this绑定-2017-9-18更新"><a href="#5-箭头函数的this绑定-2017-9-18更新" class="headerlink" title="5 . 箭头函数的this绑定 (2017.9.18更新)"></a>5 . 箭头函数的this绑定 <em>(2017.9.18更新)</em></h2><p>箭头函数，一种特殊的函数，不使用<code>function</code>关键字，而是使用<code>=&gt;</code>，学名 <code>胖箭头</code>(2333),它和普通函数的区别：</p>
<ol>
<li>箭头函数不使用我们上面介绍的四种绑定，而是<strong>完全根据外部作用域来决定this</strong>。(它的父级是使用我们的规则的哦)</li>
<li>箭头函数的this绑定无法被修改 (这个特性非常爽（滑稽）)</li>
</ol>
<p>先看个代码巩固一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    return ()=&gt;&#123;</span><br><span class="line">        console.log(this.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo.a = 10;</span><br><span class="line"></span><br><span class="line">// 1. 箭头函数关联父级作用域this</span><br><span class="line"></span><br><span class="line">var bar = foo();            // foo默认绑定</span><br><span class="line">bar();                      // undefined 哈哈，是不是有小伙伴想当然了</span><br><span class="line"></span><br><span class="line">var baz = foo.call(foo);    // foo 显性绑定</span><br><span class="line">baz();                      // 10 </span><br><span class="line"></span><br><span class="line">// 2. 箭头函数this不可修改</span><br><span class="line">//这里我们使用上面的已经绑定了foo 的 baz</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a : 999</span><br><span class="line">&#125;</span><br><span class="line">baz.call(obj);              // 10</span><br></pre></td></tr></table></figure>

<p>来来来，实战一下，还记得我们之前第一个例子吗，将它改成箭头函数的形式(可以彻底解决恶心的this绑定问题)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var people = &#123;</span><br><span class="line">    Name: &quot;海洋饼干&quot;,</span><br><span class="line">    getName : function()&#123;</span><br><span class="line">        console.log(this.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var bar = people.getName;</span><br><span class="line"></span><br><span class="line">bar();    // undefined</span><br></pre></td></tr></table></figure>

<hr>
<p>====================修改后====================</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var people = &#123;</span><br><span class="line">    Name: &quot;海洋饼干&quot;,</span><br><span class="line">    getName : function()&#123;</span><br><span class="line">        return ()=&gt;&#123;</span><br><span class="line">            console.log(this.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var bar = people.getName(); //获得一个永远指向people的函数，不用想this了,岂不是美滋滋？</span><br><span class="line"></span><br><span class="line">bar();    // 海洋饼干</span><br></pre></td></tr></table></figure>

<p>可能会有人不解为什么在箭头函数外面再套一层，直接写不就行了吗，搞这么麻烦干嘛，其实这<strong>也是箭头函数很多人用不好的地方</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj= &#123;</span><br><span class="line">    that : <span class="keyword">this</span>,</span><br><span class="line">    bar : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    baz : <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.that);  <span class="comment">// window</span></span><br><span class="line">obj.bar()();            <span class="comment">// obj</span></span><br><span class="line">obj.baz();              <span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<ol>
<li>我们先要搞清楚一点，obj的当前作用域是window,如 obj.that === window。</li>
<li>如果不用function（function有自己的函数作用域）将其包裹起来，那么默认绑定的父级作用域就是window。</li>
<li>用function包裹的目的就是将箭头函数绑定到当前的对象上。函数的作用域是当前这个对象，然后箭头函数会自动绑定函数所在作用域的this，即obj。</li>
</ol>
<p><strong>我总结</strong>：注意！obj此时的this指向的是父级作用域。</p>
<p>对于第三点，需要注意的是，只能用function包裹，不能用箭头函数包裹。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    x:<span class="number">1</span>,</span><br><span class="line">    fn:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span> &#123;<span class="keyword">this</span>.x+=<span class="number">1</span>;<span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span></span><br><span class="line">a.fn()() <span class="comment">//window</span></span><br><span class="line"><span class="built_in">console</span>.log(a.x,x) <span class="comment">//1,1</span></span><br></pre></td></tr></table></figure>

<p>如上，箭头包裹不会改变作用域，也可以理解为：<strong>箭头函数本身就没有作用域！</strong>所以的this需要他爸爸给他指定。</p>
<h2 id="6-let和const中的this（我的）"><a href="#6-let和const中的this（我的）" class="headerlink" title="6.let和const中的this（我的）"></a>6.let和const中的this（我的）</h2><p>看下面两段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    x:<span class="number">1</span>,</span><br><span class="line">    fn:<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">this</span>.x+=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span> <span class="comment">//let x = 1结果也一样</span></span><br><span class="line">a.fn()</span><br><span class="line"><span class="built_in">console</span>.log(a.x,x) 	<span class="comment">//1,1</span></span><br></pre></td></tr></table></figure>

<p>如同第5节说的，a对象中的this指向的是<strong>父级</strong>作用域，即this =&gt; window。所以第一段不能改变a中的x值！</p>
<p>在es5中全局用var、 function声明还是跟全局挂钩的，而从es6开始，let const class等都不是挂在window上了。所有顶层中的x也无法修改，因为函数中的this指向的是window<strong>而let、const的x不是挂在window上！！</strong></p>
<p>改用var时，就能更改了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    x:<span class="number">1</span>,</span><br><span class="line">    fn:<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">this</span>.x+=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line">a.fn()</span><br><span class="line"><span class="built_in">console</span>.log(a.x,x)	<span class="comment">//1,2</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>记录我的生活</title>
    <url>/2019/%E8%AE%B0%E5%BD%95%E6%88%91%E7%9A%84%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="请输入密码访问哦." />
    <label for="pass">请输入密码访问哦.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>我的生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
