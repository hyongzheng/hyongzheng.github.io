{"meta":{"title":"小狮子LittleLion","subtitle":null,"description":"每个人的心中都有一把火，过往的人却只看到烟。","author":"小狮子","url":"http://littlelion.top","root":"/"},"pages":[{"title":"about","date":"2019-09-29T17:37:11.000Z","updated":"2019-09-29T17:37:11.791Z","comments":true,"path":"about/index.html","permalink":"http://littlelion.top/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-09-29T17:37:00.000Z","updated":"2019-09-29T17:37:00.144Z","comments":true,"path":"categories/index-1.html","permalink":"http://littlelion.top/categories/index-1.html","excerpt":"","text":""},{"title":"categories","date":"2019-09-29T17:36:24.000Z","updated":"2019-09-29T17:36:24.216Z","comments":true,"path":"categories/index.html","permalink":"http://littlelion.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-29T17:36:30.000Z","updated":"2019-09-29T17:36:30.117Z","comments":true,"path":"tags/index.html","permalink":"http://littlelion.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"详解this绑定","slug":"详解this绑定","date":"2019-10-04T15:52:15.000Z","updated":"2019-10-04T15:55:13.302Z","comments":true,"path":"2019/详解this绑定/","link":"","permalink":"http://littlelion.top/2019/详解this绑定/","excerpt":"1.this绑定参看文章： 深入理解js绑定 1 . this什么是this ？在讨论this绑定前，我们得先搞清楚this代表什么。","text":"1.this绑定参看文章： 深入理解js绑定 1 . this什么是this ？在讨论this绑定前，我们得先搞清楚this代表什么。 this是JavaScript的关键字之一。它是 对象 自动生成的一个内部对象，只能在 对象 内部使用。随着函数使用场合的不同，this的值会发生变化。 this指向什么，完全取决于 什么地方以什么方式调用，而不是 创建时。（比较多人误解的地方）（它非常语义化，this在英文中的含义就是 这，这个 ，但这其实起到了一定的误导作用，因为this并不是一成不变的，并不一定一直指向当前 这个） 2 . this 绑定规则掌握了下面介绍的4种绑定的规则，那么你只要看到函数调用就可以判断 this 的指向了。 2 .1 默认绑定考虑下面代码: 123456function foo()&#123; var a = 1 ; console.log(this.a); // 10&#125;var a = 10;foo(); 这种就是典型的默认绑定，我们看看foo调用的位置，”光杆司令“，像 这种直接使用而不带任何修饰的函数调用 ，就 默认且只能 应用 默认绑定。 那默认绑定到哪呢，一般是window上，严格模式下 是undefined。 2 .2 隐性绑定代码说话: 12345678910function foo()&#123; console.log(this.a);&#125;var obj = &#123; a : 10, foo : foo&#125;foo(); // ?obj.foo(); // ? 答案 : undefined 10 foo()的这个写法熟悉吗，就是我们刚刚写的默认绑定,等价于打印window.a,故输出undefined ,下面obj.foo()这种大家应该经常写，这其实就是我们马上要讨论的 隐性绑定 。 函数foo执行的时候有了上下文对象，即 obj。这种情况下，函数里的this默认绑定为上下文对象，等价于打印obj.a,故输出10 。 如果是链性的关系，比如 xx.yy.obj.foo();, 上下文取函数的直接上级，即紧挨着的那个，或者说对象链的最后一个。 2 .3 显性绑定2 .3 .1 隐性绑定的限制在我们刚刚的 隐性绑定中有一个致命的限制，就是上下文必须包含我们的函数 ，例：var obj = { foo : foo },如果上下文不包含我们的函数用隐性绑定明显是要出错的，不可能每个对象都要加这个函数 ,那样的话扩展,维护性太差了，我们接下来聊的就是直接 给函数强制性绑定this。 2 .3 .2 call apply bind这里我们就要用到 js 给我们提供的函数 call 和 apply，它们的作用都是改变函数的this指向，第一个参数都是 设置this对象。 两个函数的区别： call从第二个参数开始所有的参数都是 原函数的参数。 apply只接受两个参数，且第二个参数必须是数组，这个数组代表原函数的参数列表。 例如： 12345function foo(a,b)&#123; console.log(a+b);&#125;foo.call(null,'海洋','饼干'); // 海洋饼干 这里this指向不重要就写null了foo.apply(null, ['海洋','饼干'] ); // 海洋饼干 除了 call，apply函数以外，还有一个改变this的函数 bind ，它和call,apply都不同。 bind只有一个函数，且不会立刻执行，只是将一个值绑定到函数的this上,并将绑定好的函数返回。例: 1234567function foo()&#123; console.log(this.a);&#125;var obj = &#123; a : 10 &#125;;foo = foo.bind(obj);foo(); // 10 （bind函数非常特别，下次和大家一起讨论它的源码） 2 .3 .2 显性绑定开始正题，上代码，就用上面隐性绑定的例子 : 1234567function foo()&#123; console.log(this.a);&#125;var obj = &#123; a : 10 //去掉里面的foo&#125;foo.call(obj); // 10 我们将隐性绑定例子中的 上下文对象 里的函数去掉了，显然现在不能用 上下文.函数 这种形式来调用函数，大家看代码里的显性绑定代码foo.call(obj)，看起来很怪，和我们之前所了解的函数调用不一样。 其实call 是 foo 上的一个函数,在改变this指向的同时执行这个函数。 （想要深入理解 [call apply bind this硬绑定,软绑定,箭头函数绑定 ] 等更多黑科技 的小伙伴欢迎关注我或本文的评论，最近我会单独做一期放到一起写一篇文章）（不想看的小伙伴不用担心，不影响对本文的理解） 2 .4 new 绑定2 .4 .1 什么是 new学过面向对象的小伙伴对new肯定不陌生，js的new和传统的面向对象语言的new的作用都是创建一个新的对象，但是他们的机制完全不同。 创建一个新对象少不了一个概念，那就是构造函数，传统的面向对象 构造函数 是类里的一种特殊函数，要创建对象时使用new 类名()的形式去调用类中的构造函数，而js中就不一样了。 js中的只要用new修饰的 函数就是’构造函数’，准确来说是 函数的构造调用，因为在js中并不存在所谓的’构造函数’。 那么用new 做到函数的构造调用后，js帮我们做了什么工作呢: 创建一个新对象。 把这个新对象的__proto__属性指向 原函数的prototype属性。(即继承原函数的原型) 将这个新对象绑定到 此函数的this上 。 返回新对象，如果这个函数没有返回其他对象。 第三条就是我们下面要聊的new绑定 2 .4 .2 new 绑定不哔哔，看代码: 12345678910function foo()&#123; this.a = 10; console.log(this);&#125;foo(); // window对象console.log(window.a); // 10 默认绑定var obj = new foo(); // foo&#123; a : 10 &#125; 创建的新对象的默认名为函数名 // 然后等价于 foo &#123; a : 10 &#125;; var obj = foo;console.log(obj.a); // 10 new绑定 使用new调用函数后，函数会 以自己的名字 命名 和 创建 一个新的对象，并返回。 特别注意 : 如果原函数返回一个对象类型，那么将无法返回新对象,你将丢失绑定this的新对象，例: 1234567function foo()&#123; this.a = 10; return new String(\"捣蛋鬼\");&#125;var obj = new foo();console.log(obj.a); // undefinedconsole.log(obj); // \"捣蛋鬼\" 我的补充 1234567function foo()&#123; this.a = 10; console.log(this); return new String(\"捣蛋鬼\"); &#125;var obj = new foo(); //foo &#123;a: 10&#125; 以上，this会输出以函数自己的名字 命名的对象。 可见：原函数先返回一个新的对象类型，再将这个对象的地址赋值给obj的。 2.4.3构造函数绑定（我的）构造函数绑定跟new是一个东西的！ 123456function Obj(name)&#123; this.name = name; console.log(this);&#125;Obj('tony'); //windowvar obj = new Obj('tony'); //obj&#123;name:'tony'&#125; new的过程，将this绑定到新对象身上的。但原始函数的this指向的是window！！ 2 .5 this绑定优先级过程是些无聊的代码测试，我直接写出优先级了 1new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 3 . 总结 如果函数被new 修饰 1this绑定的是新创建的对象，例:var bar = new foo(); 函数 foo 中的 this 就是一个叫foo的新创建的对象 , 然后将这个对象赋给bar , 这样的绑定方式叫 new绑定 . 如果函数是使用call,apply,bind来调用的 1this绑定的是 call,apply,bind 的第一个参数.例: foo.call(obj); , foo 中的 this 就是 obj , 这样的绑定方式叫 显性绑定 . 如果函数是在某个 上下文对象 下被调用 1this绑定的是那个上下文对象，例 : var obj = &#123; foo : foo &#125;; obj.foo(); foo 中的 this 就是 obj . 这样的绑定方式叫 隐性绑定 . 如果都不是，即使用默认绑定 12例:function foo()&#123;...&#125; foo() ,foo 中的 this 就是 window.(严格模式下默认绑定到undefined).这样的绑定方式叫 默认绑定 . 4 . 面试题解析1. 123456789101112var x = 10;var obj = &#123; x: 20, f: function()&#123; console.log(this.x); // ? var foo = function()&#123; console.log(this.x); &#125; foo(); // ? &#125;&#125;;obj.f(); ———————–答案———————答案 ： 20 10解析 ：考点 1. this默认绑定 2. this隐性绑定 12345678910111213141516var x = 10;var obj = &#123; x: 20, f: function()&#123; console.log(this.x); // 20 // 典型的隐性绑定,这里 f 的this指向上下文 obj ,即输出 20 function foo()&#123; console.log(this.x); &#125; foo(); // 10 //有些人在这个地方就想当然的觉得 foo 在函数 f 里,也在 f 里执行， //那 this 肯定是指向obj 啊 , 仔细看看我们说的this绑定规则 , 对应一下很容易 //发现这种'光杆司令'，是我们一开始就示范的默认绑定,这里this绑定的是window &#125;&#125;;obj.f(); 2. 12345678910function foo(arg)&#123; this.a = arg; return this&#125;;var a = foo(1);var b = foo(10);console.log(a.a); // ?console.log(b.a); // ? ———————–答案——————— 答案 ： undefined 10解析 ：考点 1. 全局污染 2. this默认绑定 这道题很有意思，问题基本上都集中在第一undefined上，这其实是题目的小陷阱，但是追栈的过程绝对精彩让我们一步步分析这里发生了什么： foo(1)执行，应该不难看出是默认绑定吧 , this指向了window，函数里等价于 window.a = 1,return window; var a = foo(1) 等价于 window.a = window , 很多人都忽略了var a 就是window.a ，将刚刚赋值的 1 替换掉了。 所以这里的 a 的值是 window , a.a 也是window ， 即window.a = window ; window.a.a = window; foo(10) 和第一次一样，都是默认绑定，这个时候，将window.a 赋值成 10 ，注意这里是关键，原来window.a = window ,现在被赋值成了10，变成了值类型，所以现在 a.a = undefined。(验证这一点只需要将var b = foo(10);删掉，这里的 a.a 还是window) var b = foo(10); 等价于 window.b = window; 本题中所有变量的值，a = window.a = 10 , a.a = undefined , b = window , b.a = window.a = 10; 3. 12345678910111213var x = 10;var obj = &#123; x: 20, f: function()&#123; console.log(this.x); &#125;&#125;;var bar = obj.f;var obj2 = &#123; x: 30, f: obj.f&#125;obj.f();bar();obj2.f(); ———————–答案———————答案：20 10 30解析：传说中的送分题，考点，辨别this绑定 12345678910111213141516var x = 10;var obj = &#123; x: 20, f: function()&#123; console.log(this.x); &#125;&#125;;var bar = obj.f;var obj2 = &#123; x: 30, f: obj.f&#125;obj.f(); // 20 //有上下文，this为obj，隐性绑定bar(); // 10 //'光杆司令' 默认绑定 （ obj.f 只是普通的赋值操作 ）obj2.f(); //30 //不管 f 函数怎么折腾，this只和 执行位置和方式有关，即我们所说的绑定规则 4. 压轴题了 12345678910111213141516function foo() &#123; getName = function () &#123; console.log (1); &#125;; return this;&#125;foo.getName = function () &#123; console.log(2);&#125;;foo.prototype.getName = function () &#123; console.log(3);&#125;;var getName = function () &#123; console.log(4);&#125;;function getName () &#123; console.log(5);&#125; foo.getName (); // ?getName (); // ?foo().getName (); // ?getName (); // ?new foo.getName (); // ?new foo().getName (); // ?new new foo().getName (); // ? ———————–答案———————答案：2 4 1 1 2 3 3解析：考点 1. new绑定 2.隐性绑定 3. 默认绑定 4.变量污染 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function foo() &#123; getName = function () &#123; console.log (1); &#125;; //这里的getName 将创建到全局window上 return this;&#125;foo.getName = function () &#123; console.log(2);&#125;; //这个getName和上面的不同，是直接添加到foo上的foo.prototype.getName = function () &#123; console.log(3);&#125;; // 这个getName直接添加到foo的原型上，在用new创建新对象时将直接添加到新对象上 var getName = function () &#123; console.log(4);&#125;; // 和foo函数里的getName一样, 将创建到全局window上function getName () &#123; console.log(5);&#125; // 同上，但是这个函数不会被使用，因为函数声明的提升优先级最高，所以上面的函数表达式将永远替换 // 这个同名函数，除非在函数表达式赋值前去调用getName()，但是在本题中，函数调用都在函数表达式 // 之后，所以这个函数可以忽略了 // 通过上面对 getName的分析基本上答案已经出来了foo.getName (); // 2 // 下面为了方便，我就使用输出值来简称每个getName函数 // 这里有小伙伴疑惑是在 2 和 3 之间，觉得应该是3 , 但其实直接设置 // foo.prototype上的属性，对当前这个对象的属性是没有影响的,如果要使 // 用的话，可以foo.prototype.getName() 这样调用 ，这里需要知道的是 // 3 并不会覆盖 2，两者不冲突 ( 当你使用new 创建对象时，这里的 // Prototype 将自动绑定到新对象上，即用new 构造调用的第二个作用) getName (); // 4 // 这里涉及到函数提升的问题，不知道的小伙伴只需要知道 5 会被 4 覆盖， // 虽然 5 在 4 的下面，其实 js 并不是完全的自上而下，想要深入了解的 // 小伙伴可以看文章最后的链接 foo().getName (); // 1 // 这里的foo函数执行完成了两件事, 1. 将window.getName设置为1, // 2. 返回window , 故等价于 window.getName(); 输出 1getName (); // 1 // 刚刚上面的函数刚把window.getName设置为1,故同上 输出 1 new foo.getName (); // 2 // new 对一个函数进行构造调用 , 即 foo.getName ,构造调用也是调用啊 // 该执行还是执行，然后返回一个新对象，输出 2 (虽然这里没有接收新 // 创建的对象但是我们可以猜到，是一个函数名为 foo.getName 的对象 // 且__proto__属性里有一个getName函数，是上面设置的 3 函数) new foo().getName (); // 3 // 这里特别的地方就来了,new 是对一个函数进行构造调用,它直接找到了离它 // 最近的函数,foo(),并返回了应该新对象,等价于 var obj = new foo(); // obj.getName(); 这样就很清晰了,输出的是之前绑定到prototype上的 // 那个getName 3 ,因为使用new后会将函数的prototype继承给 新对象 new new foo().getName (); // 3 // 哈哈，这个看上去很吓人，让我们来分解一下： // var obj = new foo(); // var obj1 = new obj.getName(); // 好了，仔细看看, 这不就是上两题的合体吗,obj 有getName 3, 即输出3 // obj 是一个函数名为 foo的对象,obj1是一个函数名为obj.getName的对象 5 . 箭头函数的this绑定 (2017.9.18更新)箭头函数，一种特殊的函数，不使用function关键字，而是使用=&gt;，学名 胖箭头(2333),它和普通函数的区别： 箭头函数不使用我们上面介绍的四种绑定，而是完全根据外部作用域来决定this。(它的父级是使用我们的规则的哦) 箭头函数的this绑定无法被修改 (这个特性非常爽（滑稽）) 先看个代码巩固一下： 123456789101112131415161718192021function foo()&#123; return ()=&gt;&#123; console.log(this.a); &#125;&#125;foo.a = 10;// 1. 箭头函数关联父级作用域thisvar bar = foo(); // foo默认绑定bar(); // undefined 哈哈，是不是有小伙伴想当然了var baz = foo.call(foo); // foo 显性绑定baz(); // 10 // 2. 箭头函数this不可修改//这里我们使用上面的已经绑定了foo 的 bazvar obj = &#123; a : 999&#125;baz.call(obj); // 10 来来来，实战一下，还记得我们之前第一个例子吗，将它改成箭头函数的形式(可以彻底解决恶心的this绑定问题)： 123456789var people = &#123; Name: &quot;海洋饼干&quot;, getName : function()&#123; console.log(this.Name); &#125;&#125;;var bar = people.getName;bar(); // undefined ====================修改后==================== 1234567891011var people = &#123; Name: &quot;海洋饼干&quot;, getName : function()&#123; return ()=&gt;&#123; console.log(this.Name); &#125; &#125;&#125;;var bar = people.getName(); //获得一个永远指向people的函数，不用想this了,岂不是美滋滋？bar(); // 海洋饼干 可能会有人不解为什么在箭头函数外面再套一层，直接写不就行了吗，搞这么麻烦干嘛，其实这也是箭头函数很多人用不好的地方 1234567891011121314var obj= &#123; that : this, bar : function()&#123; return ()=&gt;&#123; console.log(this); &#125; &#125;, baz : ()=&gt;&#123; console.log(this); &#125;&#125;console.log(obj.that); // windowobj.bar()(); // objobj.baz(); // window 我们先要搞清楚一点，obj的当前作用域是window,如 obj.that === window。 如果不用function（function有自己的函数作用域）将其包裹起来，那么默认绑定的父级作用域就是window。 用function包裹的目的就是将箭头函数绑定到当前的对象上。函数的作用域是当前这个对象，然后箭头函数会自动绑定函数所在作用域的this，即obj。 我总结：注意！obj此时的this指向的是父级作用域。 对于第三点，需要注意的是，只能用function包裹，不能用箭头函数包裹。 123456789const a = &#123; x:1, fn:()=&gt;&#123; return ()=&gt; &#123;this.x+=1;console.log(this)&#125;&#125;&#125;let x = 1a.fn()() //windowconsole.log(a.x,x) //1,1 如上，箭头包裹不会改变作用域，也可以理解为：箭头函数本身就没有作用域！所以的this需要他爸爸给他指定。 6.let和const中的this（我的）看下面两段代码： 1234567const a = &#123; x:1, fn:()=&gt;this.x+=1&#125;const x = 1 //let x = 1结果也一样a.fn()console.log(a.x,x) //1,1 如同第5节说的，a对象中的this指向的是父级作用域，即this =&gt; window。所以第一段不能改变a中的x值！ 在es5中全局用var、 function声明还是跟全局挂钩的，而从es6开始，let const class等都不是挂在window上了。所有顶层中的x也无法修改，因为函数中的this指向的是window而let、const的x不是挂在window上！！ 改用var时，就能更改了。 1234567const a = &#123; x:1, fn:()=&gt;this.x+=1&#125;var x = 1a.fn()console.log(a.x,x) //1,2","categories":[],"tags":[]},{"title":"和宝宝的生活","slug":"和宝宝的生活","date":"2019-09-30T18:40:23.000Z","updated":"2019-10-04T15:18:12.102Z","comments":true,"path":"2019/和宝宝的生活/","link":"","permalink":"http://littlelion.top/2019/和宝宝的生活/","excerpt":"第一天和宝宝见面2019年6月29号 宝宝回去之后发了豆瓣： 坐在很小的日式餐馆里，你在我左旁，我无意望着你，你也看向我，我的嘴角止不住上扬，你也笑了起来，加上很热的我感受着空调以及风扇从你那边吹过来的一阵凉风，我知道，那是心动的感觉。（昨日）","text":"第一天和宝宝见面2019年6月29号 宝宝回去之后发了豆瓣： 坐在很小的日式餐馆里，你在我左旁，我无意望着你，你也看向我，我的嘴角止不住上扬，你也笑了起来，加上很热的我感受着空调以及风扇从你那边吹过来的一阵凉风，我知道，那是心动的感觉。（昨日） 与宝宝过的中秋节 跟我的宝宝度过了愉快的两天，还一起过了中秋节，吃了月饼嘻嘻。超开心。 开心哦！","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://littlelion.top/tags/生活/"}]},{"title":"前端学习方法","slug":"前端学习方法","date":"2019-09-30T18:01:03.000Z","updated":"2019-10-04T15:30:48.570Z","comments":true,"path":"2019/前端学习方法/","link":"","permalink":"http://littlelion.top/2019/前端学习方法/","excerpt":"！！ 学习笔记 推荐使用Markdown语法 学习成本低 任何文本编辑器都可以打开","text":"！！ 学习笔记 推荐使用Markdown语法 学习成本低 任何文本编辑器都可以打开 专注于撰写内容 效率高 兼容 HTML ​ 笔记形式：记录你学习的内容，点滴 一周交一次 推荐学习网站####网站 MDN w3cplus 网易云课堂 慕课网 ####大神博客 张鑫旭 阮一峰 廖雪峰 汤姆大叔 ####博客网站 CSDN segmentfault 掘金 简书 入门书籍 《css权威指南》 《JavaScript DOM 编程艺术》 《JavaScript高级程序设计》 git, github","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://littlelion.top/tags/随笔/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-09T16:38:46.666Z","updated":"2019-09-30T18:18:01.799Z","comments":true,"path":"2019/hello-world/","link":"","permalink":"http://littlelion.top/2019/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}